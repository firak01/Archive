//Program "Plane Start"
//Starte ein Flugzeug: 1) Beschleunige, 2) Ziehe hoch
DECLARE PARAMETER argsIn, prgPlaneStart_Return.

//erwarte als erstes Argument: Die startgeschwindigkeit.
run DEBUG_Caller1("prgPlaneStart").
set STATUSx to "-99".
set prgPlaneStart_Return:ADD TO STATUSx.

//##########################
//In einer Schleife die Übergabebewerte den lokalen Variablen zuweisen.
//1. Die Startgeschwindigkeit aus der argsIn Liste holen.
//2. Die erlaubte Steuergeschwindigkeit am Boden.
run DEBUG_print0("Anzahl von Parametern in argsIn= " + argsIn:LENGTH).
set iIndex to -1.
for argIn IN argsIn {
	run DEBUG_print0("Wert: " + argIn). //argIn gilt nur innerhalb der Schleife...
	set iIndex to iIndex + 1.
	if iIndex = 0 {
	run Debug_print("param@0 = " + argIn).
		set launchSpeedMin to argIn.
		run DEBUG_print0("LaunchSpeedMin = " + launchSpeedMin).
		}.
	if iIndex = 1 {
	run Debug_print("param@1 = " + argIn).
		set launchSpeedAutoMax to argIn.
		run DEBUG_print0("LaunchSpeedMaxAuto = " + launchSpeedAutoMax).
		}.	
	if iIndex = 2 {
	run Debug_print("param@2 = " + argIn).
		set launchSteeringSpeedAutoMax to argIn.
		run DEBUG_print0("LaunchSteeringSpeedAutoMax = " + launchSteeringSpeedAutoMax).
		}.	
	if iIndex = 3 {
		run Debug_print("param@3 = " + argIn).
		set targMain to argIn.
		}.
	}.
	
	
//######################################
run STATUS_print1("STATUS=" + STATUS).

//Das Hauptziel aus der argsIn Liste holen, es ist der letzte Eintrag der Liste.
Set listListReadEntryLast_Return TO LIST().
run LIST_readEntryLast(argsIn,listListReadEntryLast_Return).
set targMain to listListReadEntryLast_Return#0.
run DEBUG_print0("Hauptziel ermittelt!"). 

//Liste mit den Argumenten an die ConsolenData-Ausgabe uebergeben!
//TODO: Entferne aus der Liste das als Parameter uebergebene Haupt-Ziel.
//           Das als Funktion machen.
set args to LIST().
set args:ADD to targMain.  

//################################
//set horizonStart to 0.         //Horizont beim Start, TODO: Auslesen wie er wirklich ist.
//set horizonCurrent to horizonStart.
set argsPitchShip to LIST().
set funPitchShip_Return to List().
run funPitchShip(argsPitchShip, funPitchShip_Return).
set langSteerHorizon to funPitchShip_Return#0.
	
//set gradeStart to targMain:HEADING.          //Richtung beim Start, TODO: Auslesen wie sie wirklich ist.
set argsGradeShip to LIST().
set funGradeShip_Return to List().
run funGradeShip(argsGradeShip, funGradeShip_Return).
set langSteerHeading to funGradeShip_Return#0.

//######################
//Funktionen mit der Steuerung verknuepfen
//LOCK STEERING TO targMain.
//set X to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
//LOCK STEERING TO X.           // Steer the vessel in the direction suggested by direction X.

//set W to HEADING(horizonCurrent, gradeCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
//LOCK WHEELSTEERING TO targMain.           // Steer the vessel in the direction suggested by direction X.
//LOCK WHEELSTEERING TO W.           // Steer the vessel in the direction suggested by direction X.

//set T to 0.0.
//LOCK THROTTLE TO T.

set langW to targMain. //fuer das Wheelsteering
set Ttemp to 0.0.
LOCK THROTTLE to langT.
LOCK STEERING TO langS.
LOCK WHEELSTEERING TO langW.

//######################
//Los geht´s....
stage. //Spare das Druecken der "Spacebar"-Taste 
run STATUS_print1("STATUS=" + STATUS).
BRAKES On.
BRAKES OFF. //Funktioniert alleine nicht.

set iSurfaceSpeedOld to 0.
set iSurfaceSpeedOldDelay to 0.
set bIsFastEnough to 0.
set bIsLaunched to 0.
set bContinue to 0.
set iCountSoft to 0.
set bIsInStartPosition to 1.



set iCount to 0. //Messungszähler
until bContinue >= 2 {	   //1=schnell genug //2 = hoch genug

	//### Konsolenausgabe vorbereiten....
	set argsShip to LIST().
	set argsShip:ADD To langSteerHeading.
	set argsShip:ADD To langSteerHorizon.
	
	set argsGradeShip to LIST().
	set funGradeShip_Return to List().
	run funGradeShip(argsGradeShip, funGradeShip_Return).
	set gradeCurrentENU to funGradeShip_Return#0.     
	set argsShip:ADD To gradecurrentENU.
	
	 set argsPitchShip to LIST().
	set funPitchShip_Return to List().
	run funPitchShip(argsPitchShip, funPitchShip_Return).
	set horizonCurrentENU to funPitchShip_Return#0.
	set argsShip:ADD To horizoncurrentENU.
	
	run subConsoleDataShip(argsShip).  //Wichtig: Erst nach den Korrektursteurn die Konsolenausgabe machne, sonst ist der aktuelle wert und der geplante Wert immer gleich.
	run subConsoleDataTarget(args). 
	
	set langSteerHorizon to ROUND(horizonCurrentENU).
	set langSteerHeading to ROUND(gradeCurrentENU).

		//### Neue Werte ausrechnen
	set iCount to iCount+1.//Achtung: Hier (in einem Unterprogram) deklarierte Variablen kann man nicht als globale Referenz uebergeben.
	set langCountGlobal to langCountGlobal+1.////Das ist der einzige Weg eine Zählvariable an eine Unterfunktion zu uebergeben. Die Variable ist in einem "ueberprogramm" deklariert und daher global
	
	set Ttemp to Ttemp + 0.01.
	
	//ggf. am Boden in die richtige Richtung fahren.
	if bIsInStartPosition = 0 {
		if Ttemp > libTmaxGround {
			set Ttemp to libTmaxGround.
		}. 
		If ROUND(SHIP:SURFACESPEED) >= 10 {
		   BRAKES On.
		}. 
		if ROUND(SHIP:SURFACESPEED) < 10 {
		  BRAKES OFF.
		}.
	}
	set langT to Ttemp.
	
	
	
	if ROUND(SHIP:SURFACESPEED) < Min(MIN(launchSteeringSpeedAutoMax, launchSpeedAutoMax),launchSpeedMin) {
	run STATUS_print1("STATUS=" + STATUS).
	    //dynamisch, laaaangsam beschleunigen. Ziel: keine konstante Geschwindigkeit behalten.
	if ROUND(SHIP:SURFACESPEED) <= iSurfaceSpeedOld {	
			set iSurfaceSpeedOldDelay to iSurfaceSpeedOldDelay + 1.
			set iSurfaceSpeedOld to ROUND(SHIP:SURFACESPEED).	
			
			if iSurfaceSpeedOldDelay >= 10 {
			set iSurfaceSpeedOldDelay to 0.			
			set Ttemp TO Ttemp + 0.05.
			if Ttemp>=0.9 { set Ttemp TO 0.9}.
			set langT TO Ttemp.			
			}
			
	}.
	
		//Korrektursteuerungen			
		set iCountSoft to iCountSoft + 2.     // 2 Grad korrektursteuerung.

		if iCountSoft >= 10 { set iCountSoft to 10. }.
		set iBearing to targMain:BEARING.
		if ROUND(iBearing) > 0 {          //als String?, ist keine Zahl
			run STATUS_print1("... Korrektursteuern nach rechts...").			
			set gradeCurrentTemp to langSteerHeading+iCountSoft+iBearing.   //rechts herum   //???? tatsächlich + iBearing ????? JA
			if gradeCurrentTemp < 0 { set gradeCurrentTemp to 360-gradeCurrentTemp. }.
			if gradeCurrentTemp > 360 { set gradeCurrentTemp to gradeCurrentTemp-360. }.
			set langSteerHeading to gradeCurrentTemp.
			SAS OFF.
			set langW to HEADING(langSteerHeading,langSteerHorizon).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont	
		}.
		if ROUND(iBearing) < 0 {		
			run STATUS_print1( "... Korrektursteuern nach links...").
			set gradeCurrentTemp to langSteerHeading-iCountSoft-iBearing.   //links herum    //???? tatsächlich - iBearing ????? JA
			if gradeCurrentTemp < 0 { set gradeCurrentTemp to 360-gradeCurrentTemp. }.
			if gradeCurrentTemp > 360 { set gradeCurrentTemp to gradeCurrentTemp-360. }.
			set langSteerHeading to gradeCurrentTemp.
			SAS OFF.
			set langW to HEADING(langSteerHeading,langSteerHorizon).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont				
		}.
		if ROUND(iBearing) = 0 {						
			run STATUS_print1("STATUS=" + STATUS).		
			run DEBUG_print1("").
			set langW to HEADING(langSteerHeading,langSteerHorizon).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont	
			set iCountSoft to 0.
			SAS ON.//Merke: bei = 0 ist Steuern nicht notwendig.
		}.	
	}. 
	
	//+++ Steuern, falls noch nicht zu schnell				
	//Unbedingt vor Tempo 100 versuchen hochzuziehen. Ggf. Antenne einziehen und Programm damit beenden.
	set iSurfaceSpeed to SHIP:SURFACESPEED.
	if Round(alt:radar) < 3 { //Nicht einen Start abbrechen, nur weil jetzt die Geschwindigkeit erreicht wurde, aber man schon in der Luft ist.
		if abs(iSurfaceSpeed) >= abs(launchSpeedAutoMax) {
			LOCK THROTTLE TO 1.
			UNLOCK WHEELSTEERING.
			UNLOCK STEERING.
			SAS OFF.
			run STATUS_print1("AUTOMAX: STEERING aus. MANU HOCHZIEHEN."). 
			run KOS_switchOff.
		}.
		
		//Das wheelsteering korregieren nach dem Ziel beenden, ab einer bestimmten Geschwindigkeit.
		if abs(iSurfaceSpeed) >= abs(launchSteeringSpeedAutoMax) {
			LOCK THROTTLE TO 1.
			UNLOCK WHEELSTEERING.
			run STATUS_print1("AUTOMAX: WHEELSTEERING  abgestellt.").
		}.
		
		if abs(iSurfaceSpeed)	>= max(launchSpeedAutoMax, launchSteeringSpeedAutoMax) {
			UNLOCK WHEELSTEERING.
			UNLOCK STEERING.
			SAS OFF.
			run STATUS_print("AUTOMAX: KOS aus. MANU HOCHZIEHEN."). //warte einige Zeit
			run KOS_switchOff.
		}. 
	}.
	
	if abs(iSurfaceSpeed) >= abs(launchSpeedMin) {
		LOCK THROTTLE TO 1.
		set bIsFastEnough to 1.
		SAS OFF.
		set langSteerHorizon to 60.
		set langS to Heading(langSteerHeading, langSteerHorizon).
		LOCK STEERING to langS.
		run STATUS_print("AUTO HOCHZIEHEN."). //warte einige Zeit
		Set STATUSx to "1".     //Automatisiert hochziehen
	}
	
	if Round(alt:radar) >= 10 {
		LOCK THROTTLE TO 1.
		set bIsLaunched to 1.
		SAS OFF.
		set langSteerHorizon to 30.
		set langS to Heading(langSteerHeading, langSteerHorizon).
		LOCK STEERING to langS.
		run STATUS_print("AUTO Weiterfliegen."). //warte einige Zeit
		GEAR OFF.   //Fahrwerk einziehen.
		SAS ON.
		Set STATUSx to "2".    //Automatisiert weiterfliegen.
	}
	
	set bContinue to bIsLaunched + bIsFastEnough.
}.
UNLOCK WHEELSTEERING.
UNLOCK STEERING.
UNLOCK THROTTLE.
set prgPlaneStart_Return:REMOVE to 0.
set prgPlaneStart_Return:ADD TO STATUSx.
