//Program "Plane Start"
//Starte ein Flugzeug: 1) Beschleunige, 2) Ziehe hoch
DECLARE PARAMETER argsIn, prgPlaneStart_Return.

//erwarte als erstes Argument: Die startgeschwindigkeit.
run DEBUG_Caller1("prgPlaneStart").
set STATUSx to "-99".
set prgPlaneStart_Return:ADD TO STATUSx.

//##########################
//In einer Schleife die Übergabebewerte den lokalen Variablen zuweisen.
//1. Die Startgeschwindigkeit aus der argsIn Liste holen.
//2. Die erlaubte Steuergeschwindigkeit am Boden.
run DEBUG_print0("Anzahl von Parametern in argsIn= " + argsIn:LENGTH).
set iIndex to -1.
for argIn IN argsIn {
	run DEBUG_print0("Wert: " + argIn). //argIn gilt nur innerhalb der Schleife...
	set iIndex to iIndex + 1.
	if iIndex = 0 {
	run Debug_print("param@0 = " + argIn).
		set launchSpeedMin to argIn.
		run DEBUG_print0("LaunchSpeedMin = " + launchSpeedMin).
		}.
	if iIndex = 1 {
	run Debug_print("param@1 = " + argIn).
		set launchSpeedAutoMax to argIn.
		run DEBUG_print0("LaunchSpeedMaxAuto = " + launchSpeedAutoMax).
		}.	
	if iIndex = 2 {
	run Debug_print("param@2 = " + argIn).
		set launchSteeringSpeedAutoMax to argIn.
		run DEBUG_print0("LaunchSteeringSpeedAutoMax = " + launchSteeringSpeedAutoMax).
		}.	
	if iIndex = 3 {
		run Debug_print("param@3 = " + argIn).
		set targMain to argIn.
		}.
	}.
	
	
//######################################
//Das Hauptziel aus der argsIn Liste holen, es ist der letzte Eintrag der Liste.
Set listListReadEntryLast_Return TO LIST().
run LIST_readEntryLast(argsIn,listListReadEntryLast_Return).
set targMain to listListReadEntryLast_Return#0.
run DEBUG_print0("Hauptziel ermittelt!"). 

//Liste mit den Argumenten an die ConsolenData-Ausgabe uebergeben!
//TODO: Entferne aus der Liste das als Parameter uebergebene Haupt-Ziel.
//           Das als Funktion machen.
set args to LIST().
set args:ADD to targMain.  

//################################
//set horizonStart to 0.         //Horizont beim Start, TODO: Auslesen wie er wirklich ist.
//set horizonCurrent to horizonStart.
set argsPitchShip to LIST().
set funPitchShip_Return to List().
run funPitchShip(argsPitchShip, funPitchShip_Return).
set horizonCurrent to funPitchShip_Return#0.
	
//set gradeStart to targMain:HEADING.          //Richtung beim Start, TODO: Auslesen wie sie wirklich ist.
set argsGradeShip to LIST().
set funGradeShip_Return to List().
run funGradeShip(argsGradeShip, funGradeShip_Return).
set gradeCurrent to funGradeShip_Return#0.

//######################
//Funktionen mit der Steuerung verknuepfen
//LOCK STEERING TO targMain.
set X to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
LOCK STEERING TO X.           // Steer the vessel in the direction suggested by direction X.

//set W to HEADING(horizonCurrent, gradeCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
LOCK WHEELSTEERING TO targMain.           // Steer the vessel in the direction suggested by direction X.
LOCK WHEELSTEERING TO W.           // Steer the vessel in the direction suggested by direction X.

set T to 0.0.
LOCK THROTTLE TO T.

//######################
//Los geht´s....
stage. //Spare das Druecken der "Spacebar"-Taste 
BRAKES On.
BRAKES OFF. //Funktioniert alleine nicht.

set iSurfaceSpeedOld to ROUND(SHIP:SURFACESPEED).
set iSurfaceSpeedOldDelay to 0.
set bIsFastEnough to 0.
set bIsLaunched to 0.
set bContinue to 0.
set iCountSoft to 0.
set bIsInStartPosition to 1.
set TmaxGround to 0.05.

set iCount to 0. //Messungszähler
until bContinue >= 2 {	   //1=schnell genug //2 = hoch genug

	//################################
    set argsPitchShip to LIST().
	set funPitchShip_Return to List().
	run funPitchShip(argsPitchShip, funPitchShip_Return).
	set horizonCurrent to funPitchShip_Return#0.
	
	//set gradeStart to targMain:HEADING.          //Richtung beim Start, TODO: Auslesen wie sie wirklich ist.
	set argsGradeShip to LIST().
	set funGradeShip_Return to List().
	run funGradeShip(argsGradeShip, funGradeShip_Return).
	set gradeCurrent to funGradeShip_Return#0.     

	set iCount to iCount+1.//Achtung: Hier (in einem Unterprogram) deklarierte Variablen kann man nicht als globale Referenz uebergeben.
	set langCountGlobal to langCountGlobal+1.////Das ist der einzige Weg eine Zählvariable an eine Unterfunktion zu uebergeben. Die Variable ist in einem "ueberprogramm" deklariert und daher global
	
	set T to T + 0.01.
	
	//ggf. am Boden in die richtige Richtung fahren.
	if bIsInStartPosition = 0 {
		if T > Tmax {
			set T to Tmax.
		}. 
		If ROUND(SHIP:SURFACESPEED) >= 10 {
		   BRAKES On.
		}. 
		if ROUND(SHIP:SURFACESPEED) < 10 {
		  BRAKES OFF.
		}.
	}
	
	if ROUND(SHIP:SURFACESPEED) < Min(MIN(launchSteeringSpeedAutoMax, launchSpeedAutoMax),launchSpeedMin) {
	
	    //dynamisch, laaaangsam beschleunigen. Ziel: keine konstante Geschwindigkeit behalten.
	if ROUND(SHIP:SURFACESPEED) <= iSurfaceSpeedOld {	
			set iSurfaceSpeedOldDelay to iSurfaceSpeedOldDelay + 1.
			set iSurfaceSpeedOld to ROUND(SHIP:SURFACESPEED).	
			
			if iSurfaceSpeedOldDelay >= 10 {
			set iSurfaceSpeedOldDelay to 0.			
			set Ttemp TO T + 0.05.
			if ROUND(Ttemp)>=0.9 { set Ttemp TO 0.9}.
			set T TO Ttemp.			
			}
			
	}.
	
		//Korrektursteuerungen			
		set iCountSoft to iCountSoft + 2.     // 2 Grad korrektursteuerung.

		if iCountSoft >= 10 { set iCountSoft to 10. }.
		set iBearing to targMain:BEARING.
		if ROUND(iBearing) > 0 {          //als String?, ist keine Zahl
			SAS OFF. //sonst ist Steuern nicht möglich
			run STATUS_print1("... Korrektursteuern nach rechts...").			
			set gradeCurrent to gradeCurrent+iCountSoft+iBearing.   //rechts herum
			run DEBUG_print1("Grad nach rechts: " + gradeCurrent).
			if gradeCurrent < 0 { set gradeCurrent to 360-gradeCurrent. }.
			if gradeCurrent > 360 { set gradeCurrent to gradeCurrent-360. }.
			
			//doppelt programmiert, aber aus performancegruenden hier sofort hinter der Berechnung
			set X to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
			set W to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
		}.
		if ROUND(iBearing) < 0 {		
			SAS OFF. //sonst ist Steuern nicht möglich
			run STATUS_print1( "... Korrektursteuern nach links...").
			set gradeCurrent to gradeCurrent-iCountSoft-iBearing.   //links herum
			run DEBUG_print1("Grad nach links: " + gradeCurrent).
			if gradeCurrent < 0 { set gradeCurrent to 360-gradeCurrent. }.
			if gradeCurrent > 360 { set gradeCurrent to gradeCurrent-360. }.
			
			//doppelt programmiert, aber aus performancegruenden hier sofort hinter der Berechnung
			set X to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
			set W to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
		}.
		if ROUND(iBearing) = 0 {			
			SAS ON.//Merke: bei = 0 ist Steuern nicht notwendig.
			run STATUS_print1( "").		
			run DEBUG_print1("").
			set iCountSoft to 0.
			
			//doppelt programmiert, aber aus performancegruenden hier sofort hinter der Berechnung
			set X to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
			set W to HEADING(gradeCurrent,horizonCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
		}.	
	}. 
	
	set argsShip to LIST().
	set argsShip:ADD To gradecurrent.
	set argsShip:ADD To horizoncurrent.
	run subConsoleDataShip(argsShip).  //Wichtig: Erst nach den Korrektursteurn die Konsolenausgabe machne, sonst ist der aktuelle wert und der geplante Wert immer gleich.
	run subConsoleDataTarget(args). 
	
	
	
	//+++ Steuern, falls noch nicht zu schnell				
	//Unbedingt vor Tempo 100 versuchen hochzuziehen. Ggf. Antenne einziehen und Programm damit beenden.
	set iSurfaceSpeed to SHIP:SURFACESPEED.
	if Round(alt:radar) < 3 { //Nicht einen Start abbrechen, nur weil jetzt die Geschwindigkeit erreicht wurde, aber man schon in der Luft ist.
		if abs(iSurfaceSpeed) >= abs(launchSpeedAutoMax) {
			LOCK THROTTLE TO 1.
			UNLOCK WHEELSTEERING.
			UNLOCK STEERING.
			SAS OFF.
			run STATUS_print1("AUTOMAX: STEERING aus. MANU HOCHZIEHEN."). 
			run KOS_switchOff.
		}.
		
		//Das wheelsteering korregieren nach dem Ziel beenden, ab einer bestimmten Geschwindigkeit.
		if abs(iSurfaceSpeed) >= abs(launchSteeringSpeedAutoMax) {
			LOCK THROTTLE TO 1.
			UNLOCK WHEELSTEERING.
			run STATUS_print1("AUTOMAX: WHEELSTEERING  abgestellt.").
		}.
		
		if abs(iSurfaceSpeed)	>= max(launchSpeedAutoMax, launchSteeringSpeedAutoMax) {
			UNLOCK WHEELSTEERING.
			UNLOCK STEERING.
			SAS OFF.
			run STATUS_print("AUTOMAX: KOS aus. MANU HOCHZIEHEN."). //warte einige Zeit
			run KOS_switchOff.
		}. 
	}.
	
	if abs(iSurfaceSpeed) >= abs(launchSpeedMin) {
		LOCK THROTTLE TO 1.
		set bIsFastEnough to 1.
		SAS OFF. //Abstellen und bis zum Abheben abgestellt lassen.
		set horizonCurrent to 60.
		//set X to HEADING(targMain:HEADING, horizonCurrent).     
		//fehler set X to targMain:Heading by horizonCurrent.
		//klappt nicht LOCK STEERING TO targMain:Heading by horizonCurrent.
		//set X to HEADING(gradecurrent, horizonCurrent).  
		//set X to UP + R(60, 0, 0).		
		//set X to V(1,1,3) *surface		
		//set gradecurrent to SHIP:HEADING.
		set X to Heading(gradecurrent, horizoncurrent).
		LOCK STEERING TO X.
		//funktioniert nicht LOCK STEERING TO gradecurrent by horizoncurrent.
		run STATUS_print("AUTO HOCHZIEHEN."). //warte einige Zeit
		Set STATUSx to "1".     //Automatisiert hochziehen
	}
	
	//abs(SHIP:surfacespeed) >= abs(launchSpeedMin)
	if Round(alt:radar) >= 10 {
		LOCK THROTTLE TO 1.
		set bIsLaunched to 1.
		set horizonCurrent to 0.
		set X to Heading(gradecurrent, horizoncurrent).
		//set X to UP + R(10, 0,0).	
		//set X to V(1,1,1) *surface				
		LOCK STEERING TO X.
		//funtioniert nicht LOCK STEERING TO gradecurrent by horizoncurrent.
		run STATUS_print("AUTO Weiterfliegen."). //warte einige Zeit
		GEAR OFF.   //Fahrwerk einziehen.
		SAS ON.
		Set STATUSx to "2".    //Automatisiert weiterfliegen.
	}
	
	set bContinue to bIsLaunched + bIsFastEnough.
}.
set prgPlaneStart_Return:REMOVE to 0.
set prgPlaneStart_Return:ADD TO STATUSx.
