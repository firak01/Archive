//Program "Plane Start"
//Starte ein Flugzeug: 1) Beschleunige, 2) Ziehe hoch
DECLARE PARAMETER argsIn, prgPlaneFlight_Return.

//erwarte als erstes Argument: Das Ziel 
run DEBUG_Caller1("prgPlaneFlight").
set STATUSx to "-99".
set prgPlaneFlight_Return:ADD TO STATUSx.

//##########################
//In einer Schleife die Übergabebewerte den lokalen Variablen zuweisen.
//1. Die Startgeschwindigkeit aus der argsIn Liste holen.
//2. Die erlaubte Steuergeschwindigkeit am Boden.
run DEBUG_print1("Anzahl von Parametern in argsIn= " + argsIn:LENGTH).
set iIndex to -1.
for argIn IN argsIn {
	run DEBUG_print1("Wert: " + argIn). //argIn gilt nur innerhalb der Schleife...
	set iIndex to iIndex + 1.
	if iIndex = 0 {
		set iHeightGoal to argIn.
		run DEBUG_Caller("Height Goal = " + iHeightGoal).
		}.
	if iIndex = 1 {
		set iDistTargGoal to argIn.
		run DEBUG_Caller("DistTarg Goal = " + iDistTargGoal).
		}.
	if iIndex = 2 {
		//run printDebug("param@2 = " + argIn).
		//set targMain to argIn.
		}.
	}.
	
	
//########################################
set iCount to 0. //Messungszähler
	
//Das Hauptziel aus der argsIn Liste holen, es ist der letzte Eintrag der Liste.
Set listListReadEntryLast TO LIST().)
run LIST_readEntryLast(argsIn, listListReadEntryLast).
set targMain to listListReadEntryLast#0.

//Gesamtliste aller (anderen) Ziele
//TODO: Entferne aus der Liste das als Parameter uebergebene Haupt-Ziel.
//           Das als Funktion machen.
SET listTarg TO LIST().   // Creates a new list in FOO variable
SET listTarg:ADD TO targMain.
SET listTarg:ADD TO libTargKscRunEnd.    // Adds a new element to the end of the list
SET listTarg:ADD TO libTargPolNor.


//######################
//TODO: Diese Werte in die lib der Maschine aufnehmen (lib7p08.txt)
set constHorizonUpMax to 60. //Die Maximalwerte fuer das Flugverhalten der Maschine.
set constHorizonDownMax to -20.
set horizonGoalUp to constHorizonUpMax. //wie stark die Hoehenveraenderung sein soll.
set horizonGoalDown to -5.
set horizonCurrent to horizonGoalUp.

//Funktionen mit der Steuerung verknuepfen
set gradeStart to targMain:HEADING.          //Richtung beim Start, TODO: Auslesen wie sie wirklich ist.
set gradeCurrent to gradeStart.

LOCK THROTTLE to 1.
set X to HEADING(horizonCurrent, gradeCurrent).     //gehe auf 90 Grad (startrichtung auf Startbahn), 55 Grad ?ber den Horizont
LOCK STEERING TO X.           // Steer the vessel in the direction suggested by direction X.

//######################	
//Bis auf Zielnähe fliegen.
set bContinue to 0.
//until Round(targMain:DISTANCE)<=Round(iDistTargGoal) {
until bContinue >= 1 {
	set iCount to iCount + 1.
	run subConsoleDataStart (listTarg).
	
	
	//+++ Hoehenangabe
	set altitude to SHIP:ALTITUDE.
		
	//Ziel: Bei niedriger Hoehe ggf. alt:radar verwenden, um Bergspitzen auszuweichen!
	//These lines determine if the object is flying over water. If it is, the object determins its height based on altitude, not radalt.
	if altitude <= 4000 {
		set height to alt:radar.
		if alt:radar < 0 {set height to altitude.}.
		if alt:radar > altitude {set height to altitude.}.
	}.
	if altitude > 4000 {
		set height to altitude.
	}.
	
	//Ziel: Langsam den Kurs aendern.
	//TODO: Algorithmus aus prgPlaneStart wiederverwenden. (als eigenen Funktion kapseln?)
	set bGradeGoal to 0.
	if height > 200 { 
		set bGradeGoal to 1.
		if gradeCurrent != ROUND(targMain:BEARING) {			    
			set bGradeGoal to 0.
			if abs(gradeCurrent - abs(ROUND(targMain:BEARING))) >= 180 {
				run STATUS_print("... korrektursteuern nach rechts...").
				set gradeCurrent to gradeCurrent+iCountSoft.   //rechts herum
				if gradeCurrent > 360 { set gradeCurrent to 360. }.
			}.
			if abs(gradeCurrent - abs(ROUND(targMain:BEARING))) < 180 {					
				run STATUS_print("... korrektursteuern nach links...").
				set gradeCurrent to gradeCurrent-iCountSoft.   //links herum
				if gradeCurrent < 0 { set gradeCurrent to 0. }.
			}.
		}.
	}. //if height > x
	
	//Ziel: Höhe erreichen und dann halten
	//until SHIP:altitude >= iHeightGoal{
	set bHightGoal to 1.	
	set sAltitudeControl to sMissionStepTxt + ": Hoehenkorridor halten.".
	set horizonExtreme to 0.
	if ROUND(height) < iHeightGoal - (iHeightGoal/10) { 
		set horizonExtreme to horizonGoalUp.
		set horizonCurrent to horizonGoalUp.
		set sAltitudeControl to sMissionStepTxt + ": Hochziehen!".
		set iCountSoft to 0. // set iCountSoft to iCountSoft + 1.  //muss das nicht auch set iCountSoft to 0. sein?
		set bHeightGoal to 0.
	}.
	if ROUND(height) > iHeightGoal + (iHeightGoal/10) { 
		set horizonExtreme to horizonGoalDown.
		set horizonCurrent to horizonGoalDown.
		set sAltitudeControl to sMissionStepTxt + ": Runterziehen!".
		set iCountSoft to 0. //set iCountSoft to iCountSoft + 1.  //muss das nicht auch set iCountSoft to 0. sein?
		set bHeightGoal to 0.
	}.
	run STATUS_print(sAltitudeControl). 
		 
	if bHeightGoal = 0 {	 
		//+++ Anstiegswinkel verringern und schon leicht eine Kurve fliegen. Aber die Extermbelastungen vermeiden.
		if horizonExtreme = 0 { 
			//Teste, fliege gleichmaessiger
			if abs(horizonCurrent)-iCountSoft > 0 {
				set iCountSoft to iCountSoft + 1.
			}.
			if abs(horizonCurrent)-iCountSoft <= 0 {
				 set iCountSoft to 0.
			}.
			//Vermeide ueberschreiten der erlaubten Belastung.
			set horizonCurrent to horizonCurrent-iCountSoft.
			if horizonCurrent > horizonGoalUp {
				set horizonCurrent to horizonGoalUp.
			}.
			if horizonCurrent < horizonGoalDown {
				set horizonCurrent to horizonGoalDown.
			}.
		}.
	}.
		
	//Zielparameter erreicht?
	set bContinue to 1.
	if bGradeGoal = 0 { set bContinue to 0. }.
	if bHeightGoal = 0 { set bContinue to 0. }.	
}.

Set STATUSx to "1".
set prgPlaneFlight_Return:REMOVE to 0.
set prgPlaneFlight_Return:ADD TO STATUSx.
	